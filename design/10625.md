# EP-10625: Invalid Route Replacement

*Issue*: [#10625](https://github.com/kgateway-dev/kgateway/issues/10625)

## Background

Currently, when a user adds an invalid route — for example, a route to an upstream that does not exist — the system sets the output route to `nil`, causing it to be dropped from the xDS snapshot sent to Envoy. In many scenarios, this results in requests that would have matched that route instead falling through to a default listener catch-all and receiving a 404 response from Envoy.

However, this behavior can introduce correctness and security issues, especially in multi-tenant environments. A route silently disappearing can cause routing to fallback to unintended services or expose paths without intended policy protections.

As a result, this proposal is focused on introducing invalid route replacement as a control plane guardrail. This prevents invalid configurations from altering expected routing behavior, maintain Gateway API specification compliance, while ensuring that invalid routes do not introduce security or correctness regressions in the dataplane.

### Problem Scenarios

1. **Mis-routed requests**
   Example:
   **Route 1** matches `/path/bad` → Service A
   **Route 2** matches `/path` → Service B
   If Route 1 is invalid and dropped, requests to `/path/bad` erroneously match Route 2 and succeed (e.g., return 200), hiding routing errors and potentially misrouting traffic

2. **Accidental exposure without security policies**
   If a route relies on authentication (e.g., `/userInfo` protected by `TrafficPolicy`) and that policy fails to attach or is misconfigured, the route may be exposed without authentication. This creates a **fail-open** scenario where traffic to protected paths is allowed.

3. **Undetected invalid transformations**
   `TrafficPolicy` supports transformation filters using **Inja templates**. These templates can be valid at the CRD level but fail at the xDS or runtime level. Such failures are undetectable during admission and require deeper validation handling.

4. **Control plane produces invalid xDS due to unknown/unknowns**
   A bug or logic oversight may result in valid Kubernetes resources producing invalid xDS output. These cases are not caught at admission or schema-validation time and only manifest when Envoy NACKs the configuration.

5. **Dataplane loses valid config on restart**
   Even if Envoy initially NACKs a bad config and retains its last-known-good (LKG) config in memory, this state is **not persisted across restarts**. Upon restart, Envoy contacts the control plane with an empty cache, and if the current snapshot is still invalid, it will refuse to serve traffic entirely. There is no relay mechanism in Envoy to pull back its LKG from the control plane, making recovery fragile without upstream fallback logic.

## Gateway‑API Specification Compliance

- **Listener: `allowedRoutes`** (§ `Listener.allowedRoutes`)
  > *"Invalid Route rules can be ignored … If a Route rule transitions from valid to invalid, support for that Route rule should be dropped …"*
- **HTTPRouteRule: `matches`** (§ `HTTPRouteRule.matches`)
  > *"When no rules matching a request have been successfully attached … an HTTP 404 status code MUST be returned."*
- **ExtensionRef: `extensionRef`** (§ `HTTPRouteFilter.extensionRef`)
  > *"If the object referenced by an `ExtensionRef` cannot be found or is invalid, implementations MUST NOT skip the filter and SHOULD return an HTTP 500 status."*

These statements allow implementations to drop invalid rules. However, dropping the rule without installing a guard route can lead to the "mis‑route" and "authn bypass" scenarios above.

Additionally, for supported external policy types like authorization and global rate limiting, which defer behavior to a user-supplied resource, we adopt the same approach as `ExtensionRef`. These BYO-style fields follow the same referential risk pattern and must result in HTTP 500 if the referenced resource is missing or invalid.

### Error Classification

This section outlines the difference between error handling for **Gateway API core resources** and **extension APIs** like `TrafficPolicy`.

#### Core Gateway API Resources

These include `xRoute`, `Gateway`, and related standard resources provided Kubernetes.

| Type        | Examples                                                                 | Error Class     |
| ----------- | ------------------------------------------------------------------------ | --------------- |
| Referential | `backendRef` points to non-existent `Service`; missing `ReferenceGrant`  | Referential     |
| Structural  | Invalid `match` config (bad regex), mutually exclusive filters           | Structural      |
| Semantic    | Weight sum of 0; misconfig that passes validation but routes incorrectly | Semantic (rare) |

These errors are governed by explicit spec guidance. For example, unmatched routes must 404, and invalid but matched routes must fail with 500.

#### Extension APIs (e.g. `TrafficPolicy`)

These are project-specific resources layered on top of core Gateway APIs.

| Type        | Examples                                                                         | Error Class |
| ----------- | -------------------------------------------------------------------------------- | ----------- |
| Referential | Missing `gatewayExtensionRef` for ExtAuth or RateLimit provider                  | Referential |
| Structural  | Inja templates with invalid syntax; bad CEL expressions; missing required fields | Structural  |
| Semantic    | - Auth policy misconfiguration disables security (e.g., fail-open behavior)      | Semantic    |
|             | - Attachment misconfiguration: `spec.targetRefs` does not select expected `HTTPRoute`, leaving paths unprotected | Semantic    |
|             | - Policy silently ignored due to logic bugs despite `Accepted=True` | Semantic    |
|             | - Runtime transformation failure (e.g., invalid Inja templates evaluated in Envoy) | Semantic    |

Unlike the core APIs, these errors may only surface during IR construction, partial xDS validation, or even at runtime in Envoy. Therefore, handling must occur inside the translator's plugin and validation pipeline.

## Previous (1.x) Approach

The legacy implementation ran [`envoy --mode validate`](https://www.envoyproxy.io/docs/envoy/latest/start/quick-start/run-envoy) against every xDS snapshot:

- Helped enforce that invalid configurations lead to the whole snapshot being rejected
- Lacked granularity that would allow for more fine-grained control over the replacement behavior
- Expensive (CPU/memory) for large snapshots
- Included webhook integration to reject invalid configurations at admission time, but this proved brittle due to performance, ordering, and availability issues

## Motivation

- Multi-tenant safety on shared Gateways
- Ensure secure routes are never exposed without their policies
- Preserve atomicity – a broken route must not influence any other route
- Provide precise metrics and status for operator debugging

### Goals

- Prevent invalid configurations from silently altering routing behavior
- Ensure security policies are never bypassed due to invalid configurations
- Provide clear feedback when configurations are invalid
- Maintain compliance with Gateway API specification for invalid route handling
- Add a global feature-gate (Helm value) to enable/disable the behavior

### Non‑Goals

- Provide a validating webhook implementation to prevent misconfiguration at admission time
- Provide per-route or per-gateway opt-outs semantics
- Provide two different toggles for route replacement and policy validation
- Enable users to further customize the replacement status code/body

## Implementation Details

### Installation & Configuration

A new feature flag will be introduced to enable/disable the feature.

```yaml
invalidRouteReplacement:
  enabled: false   # default
```

This flag will be plumbed into `settings.go` and surfaced through the Helm chart.

## Translator Changes

The translator's behavior will change significantly when the feature gate is enabled. Here's how each phase will be affected:

1. **Plugin Application (via `ApplyForX` methods)**
   - **Current**: Plugins return errors through `ApplyForX` methods, which the translator uses to set routes to `nil`. This approach was necessary to handle attachment-related issues at runtime, e.g. direct response plugin
   - **Proposed**: `ApplyForX` methods will become pure functions that only mutate the output xDS configuration and remove error handling entirely. This will remove one class of errors from the route translator and help leanup the codebase
2. **Spec to IR Construction**
   - **Current**: Policy errors encountered during IR construction are collected but not checked before applying the policy. The route translator's call site checks for non-nil errors and sets the output route to `nil` if any errors are found
   - **Proposed**: Policy errors will be checked during IR construction before applying the policy. This will continue to influence status reporting while also triggering route replacement when policy IR reports errors, ensuring consistent error handling across all validation phases
3. **Structural Validation**
   - **Current**: Regex/path validation errors cause the route to be set to `nil`
   - **Proposed**: The same replacement logic will apply consistently across all validation failures
4. **xDS Validation**
   - **Current**: No validation of generated xDS configuration
   - **Proposed**: Implement two-tiered xDS validation:
     1. Plugin-level validation during IR construction:
        - Each plugin validates its filter configuration by converting its IR to a partial Envoy bootstrap config
        - Uses a fake listener containing the plugin's filters
        - Runs `envoy --mode validate` against this partial config
        - Optimize by comparing policy status's observed generation against current generation to short-circuit validation for metadata-only updates (and ignore updates to attached HTTPRoute status)
     2. Route translator validation:
        - Validates the complete output route configuration
        - Caches validation results for performance
        - Ensures the final xDS configuration is valid before being sent to Envoy

### Validation Pipeline

1. **CRD (Kubernetes) schema validation** – enforced by Kubernetes at admission time
2. **PGV schema validation** – runtime checks for constraints defined in Go/protobuf
3. **Partial xDS validation** – build partial Envoy config and run `envoy --mode validate`
4. **Translator decision** – any terminal error triggers route replacement

### Observability

| Metric                             | Type    | Labels                                                    |
| ---------------------------------- | ------- | --------------------------------------------------------- |
| `invalid_route_replacements_total` | Counter | `gateway`, `route_namespace`, `route_name`, `error_class` |
| `policy_validation_failures_total` | Counter | `policy_kind`, `namespace`, `name`, `reason`              |

Status reporting:

* HTTPRoute: `PartiallyInvalid=True` if at least one rule was replaced
* Policy: `Accepted=False` / `ResolvedRefs=False` with `Reason` condition

### Test Plan

* Unit: classification logic and feature-gate toggles
* Integration: confirm sibling routes are isolated and unaffected
* E2E: simulate misroutes, insecure paths, transformation failures

## Glossary

| Term              | Definition |
|-------------------|------------|
| Referential Error | A failure caused by referencing a non-existent or unresolved resource (e.g., missing Service, ReferenceGrant, ExtensionRef, or GatewayExtension) |
| Structural Error  | A failure due to schema or config issues (e.g., bad regex, mutually exclusive fields, invalid Inja/CEL expressions). Detected via CRD validation, PGV, or xDS rejection |
| Semantic Error    | Configurations that are schema-valid but logically incorrect or unsafe. Examples include fail-open security behavior, incorrect targetRefs, or silent runtime errors in filters |
