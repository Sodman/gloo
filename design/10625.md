# EP-10625: Invalid Route Replacement

*Issue*: [#10625](https://github.com/kgateway-dev/kgateway/issues/10625)

## Background

Currently, when a user adds an invalid route — for example, a route to an upstream that does not exist — the system sets the output route to `nil`, causing it to be dropped from the xDS snapshot sent to Envoy. In many scenarios, this results in requests that would have matched that route instead falling through to a default listener catch-all and receiving a 404 response from Envoy.

However, this behavior can introduce correctness and security issues, especially in multi-tenant environments. A route silently disappearing can cause routing to fallback to unintended services or expose paths without intended policy protections.

### Historical Context (1.x Behavior)

The legacy implementation ran [`envoy --mode validate`](https://www.envoyproxy.io/docs/envoy/latest/start/quick-start/run-envoy) against every xDS snapshot:

- Helped enforce that invalid configurations lead to the whole snapshot being rejected
- Lacked granularity that would allow for more fine-grained control over the replacement behavior
- Expensive (CPU/memory) for large snapshots
- Included webhook integration to reject invalid configurations at admission time, but this proved brittle due to performance, ordering, and availability issues

## Motivation

This proposal brings invalid route replacement to the 2.x version of the project, a feature that was previously available in the 1.x project. While not natively supported by the Kubernetes Gateway API specification currently, this feature has proven invaluable for gateway users over the years, preventing production outages and security incidents. The feature significantly improves the user experience and quality of life for gateway administrators and route creators, while providing stronger guarantees for route atomicity.

### Problem Scenarios

1. **Mis-routed requests**
   Example:
   **Route 1** matches `/path/bad` → Service A
   **Route 2** matches `/path` → Service B
   If Route 1 is invalid and dropped, requests to `/path/bad` erroneously match Route 2 and succeed (e.g., return 200), hiding routing errors and potentially misrouting traffic

2. **Accidental exposure without security policies**
   If a route relies on authentication (e.g., `/userInfo` protected by `TrafficPolicy`) and that policy fails to attach or is misconfigured, the route may be exposed without authentication. This creates a **fail-open** scenario where traffic to protected paths is allowed.

3. **Undetected invalid transformations**
   `TrafficPolicy` supports transformation filters using **Inja templates**. These templates can be valid at the CRD level but fail at the xDS or runtime level. Such failures are undetectable during admission and require deeper validation handling.

4. **Control plane produces invalid xDS due to unknown/unknowns**
   A bug or logic oversight may result in valid Kubernetes resources producing invalid xDS output. These cases are not caught at admission or schema-validation time and only manifest when Envoy NACKs the configuration.

5. **Dataplane loses valid config on restart**
   Even if Envoy initially NACKs a bad config and retains its last-known-good (LKG) config in memory, this state is **not persisted across restarts**. Upon restart, Envoy contacts the control plane with an empty cache, and if the current snapshot is still invalid, it will refuse to serve traffic entirely. There is no relay mechanism in Envoy to pull back its LKG from the control plane, making recovery fragile without upstream fallback logic.

### Goals

- Prevent invalid configurations from silently altering routing behaviour, in addition to limiting the blast radius in multi-tenant environments
- Ensure security policies are never bypassed because of misconfiguration
- Provide clear, actionable feedback through status conditions and Prometheus metrics
- Maintain compliance with Gateway API specification for invalid route handling
- Add a global feature-gate (via Helm) to enable/disable the behavior
- Enable granular validation that isolates invalid configurations while preserving valid ones, providing better visibility into which resources cause validation failures

### Non-Goals

- Provide a validating webhook implementation to prevent misconfiguration at admission time
- Provide per-route or per-Gateway opt-out mechanisms
- Expose multiple independent toggles for route replacement and policy validation
- Allow user-defined custom response bodies or status codes for the replacement route

## Gateway‑API Specification Compliance

- **Listener: `allowedRoutes`** (§ `Listener.allowedRoutes`)
  > *"Invalid Route rules can be ignored … If a Route rule transitions from valid to invalid, support for that Route rule should be dropped …"*
- **HTTPRouteRule: `matches`** (§ `HTTPRouteRule.matches`)
  > *"When no rules matching a request have been successfully attached … an HTTP 404 status code MUST be returned."*
- **ExtensionRef: `extensionRef`** (§ `HTTPRouteFilter.extensionRef`)
  > *"If the object referenced by an `ExtensionRef` cannot be found or is invalid, implementations MUST NOT skip the filter and SHOULD return an HTTP 500 status."*

These statements allow implementations to drop invalid rules. However, dropping the rule without installing a guard route can lead to the "mis‑route" and "authn bypass" scenarios above.

Additionally, for supported external policy types like authorization and global rate limiting, which defer behavior to a user-supplied resource, we adopt the same approach as `ExtensionRef`. These BYO-style fields follow the same referential risk pattern and must result in HTTP 500 if the referenced resource is missing or invalid.

## Implementation Details

### Installation & Configuration

A new feature flag will be introduced to enable/disable the feature.

```yaml
invalidRouteReplacement:
  enabled: false   # default
```

This flag will be plumbed into `settings.go` and surfaced through the Helm chart.

## Translator Changes

A tiered validation approach will be introduced to catch and handle invalid configurations at different stages:

1. **Admission Time**: CEL validation in extension CRDs prevents invalid configurations from being created, in addition to catching attachment related errors
2. **IR Construction**: Policy errors are checked during IR construction, influencing both status reporting and route replacement going forward
3. **xDS Generation**: Plugins validate their filter configurations using partial Envoy configs
4. **Final Validation**: Route translator validates the complete configuration before sending to Envoy, without validating the entire snapshot

This multi-layered pipeline approach ensures we catch invalid configurations as early as possible while maintaining consistent error handling across all stages, in addition to providing a more fine-grained control over which resources trigger route replacement.

### Current vs Proposed Behavior

#### Plugin Application (via `ApplyForX` methods)

- **Current**: Plugins return errors through `ApplyForX` methods, which the translator uses to set routes to `nil`. This approach was necessary to handle attachment-related issues at runtime, e.g. direct response plugin
- **Proposed**: `ApplyForX` methods will become pure functions that only mutate the output xDS configuration and remove error handling entirely. This will remove one class of errors from the route translator and help cleanup the codebase

#### Spec to IR Construction

- **Current**: Policy errors encountered during IR construction are collected but not checked before applying the policy. The route translator's call site checks for non-nil errors and sets the output route to `nil` if any errors are found
- **Proposed**: Policy errors will be checked during IR construction before applying the policy. This will continue to influence status reporting while also triggering route replacement when policy IR reports errors, ensuring consistent error handling across all validation phases

#### Structural Validation

- **Current**: Regex/path validation errors cause the route to be set to `nil`
- **Proposed**: The same replacement logic will apply consistently across all validation failures

#### xDS Validation

- **Current**: No validation of generated xDS configuration
- **Proposed**: Implement two-tiered xDS validation
  1. Plugin-level validation during IR construction
     - Relevant plugins first perform PGV validation against their filter types stored in the IR
     - If PGV passes, plugins then validate their filter configuration by converting their IR to a partial Envoy bootstrap config
     - Uses a fake listener containing the plugin's filters
     - Runs `envoy --mode validate` against this partial config
     - Optimize by comparing policy status's observed generation against current generation to short-circuit validation for metadata-only updates (and ignore updates to attached HTTPRoute status) and by only validating the plugin's filters
  2. Route translator validation
     - Validates the complete output route configuration
     - Caches validation results for performance
     - Ensures the final xDS configuration is valid before being sent to Envoy

### Observability

TODO(tim): Re-evaluate this section.

| Metric                             | Type    | Labels                                                    |
| ---------------------------------- | ------- | --------------------------------------------------------- |
| `invalid_route_replacements_total` | Counter | `gateway`, `route_namespace`, `route_name`, `error_class` |
| `policy_validation_failures_total` | Counter | `policy_kind`, `namespace`, `name`, `reason`              |

Status reporting:

- HTTPRoute: `PartiallyInvalid=True` if at least one rule was replaced
- Policy: `Accepted=False` / `Invalid=True`

### Test Plan

TODO(tim): Update this section.

- Unit: classification logic and feature-gate toggles
- Integration: confirm sibling routes are isolated and unaffected
- E2E: simulate misroutes, insecure paths, transformation failures

## Alternatives

- Continue eliding invalid routes: status quo; risks mis-routed traffic
- Admission time rejection: ideal, but not always feasible, particularly when validation involves multiple resources
- Delay pushing updates to Envoy until the entire IR validates: fallback to the last-known-good snapshot; requires durable storage for LKG state, coordinated rollback logic across control-plane replicas, and blocks unrelated valid changes until every error is resolved

## Glossary

| Term              | Definition | Potential Risk |
|-------------------|------------|-------------------------|
| Referential Error | A failure caused by referencing a non-existent or unresolved resource (e.g., missing Service, ReferenceGrant, ExtensionRef, GatewayExtension, or invalid policy targetRefs). | Invalid routes may be silently removed; requests fall through to a catch-all and return 404/503—or worse, reach an unintended backend—creating correctness and security gaps that are hard to trace from Kubernetes status alone. |
| Structural Error | A failure due to schema or config issues (e.g., bad regex, mutually exclusive fields, invalid Inja/CEL expressions). Detected via CRD validation, PGV, or xDS rejection. | If not rejected cleanly, the controller can program broken config that Envoy NACKs, causing reconcile loops, partial outages, or proxy crash-loops; operators see healthy status in Kubernetes while traffic drops or flaps. |
| Semantic Error | Configurations that are schema-valid and referentially correct but logically incorrect or unsafe. Examples include fail-open security behavior, conflicting path rewrites, or silent runtime errors in filters. | Unsafe logic ships to the data-plane: auth bypass, wildcard route hijacking, redirect loops, MTLS downgrades, etc. Traffic continues to flow, but in ways that violate intent or security posture, leading to incidents despite all status conditions showing green. |

### Error Classification

TODO(tim): Re-evaluate this section.

This section outlines the difference between error handling for **Gateway API core resources** and **extension APIs** like `TrafficPolicy`.

> See the [Glossary](#glossary) for definitions on the different error types.

#### Core Gateway API Resources

These include `xRoute`, `Gateway`, and related standard resources provided Kubernetes.

| Error Type  | Examples                                                                 |
| ----------- | ------------------------------------------------------------------------ |
| Referential | `backendRef` points to non-existent `Service`; missing `ReferenceGrant`  |
| Structural  | Invalid `match` config (bad regex), mutually exclusive filters           |
| Semantic    | Weight sum of 0; misconfig that passes validation but routes incorrectly |

These errors are governed by explicit spec guidance. For example, unmatched routes must 404, and invalid but matched routes must fail with 500.

#### Extension APIs (e.g. `TrafficPolicy`)

These are project-specific resources layered on top of core Gateway APIs.

| Error Type  | Examples                                                                         |
| ----------- | -------------------------------------------------------------------------------- |
| Referential | Missing `gatewayExtensionRef` for ExtAuth or RateLimit provider                  |
| Structural  | Inja templates with invalid syntax; bad CEL expressions; missing required fields |
| Semantic    | - Auth policy misconfiguration disables security (e.g., fail-open behavior)      |
|             | - Attachment misconfiguration: `spec.targetRefs` does not select expected `HTTPRoute`, leaving paths unprotected |
|             | - Policy silently ignored due to logic bugs despite `Accepted=True` |
|             | - Runtime transformation failure (e.g., invalid Inja templates evaluated in Envoy) |

Unlike the core APIs, these errors may only surface during IR construction, partial xDS validation, or even at runtime in Envoy. Therefore, handling must occur inside the translator's plugin and validation pipeline.
